---
title: "Statlearninghw1"
author: "Sam Reade, Ava Exelbirt"
date: "2024-11-08"
output: html_document 
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Statistical Learning Homework 1:

```{r}
knitr::opts_chunk$set(echo = TRUE)
install.packages("tidytuesdayR")
install.packages("ggcorrplot")
install.packages("psych")
library(psych)
library(ggcorrplot)
library(dplyr)
library(tidyr)
library(ggplot2)
```

Goals: - predict neighborhood / county by price - predict price by
square footage - find relationships between year and price - predict \#
of beds by price or price by number of beds - maybe do something with
embeddings for the titles for more info about home - correlate with
price

```{r}
Rent_df = tidytuesdayR::tt_load('2022-07-05')
```

```{r}
Rent = Rent_df$rent
Permits = Rent_df$sf_permits
Construction = Rent_df$new_construction
```

# Data Preprocessing:

```{r}
head(Rent)
dim(Rent)
```

# Data Cleanup:

```{r}
# Check number of Duplicate Rows: 
num_duplicates = sum(duplicated(Rent))
print(num_duplicates)
```

# Checking unique values of categorical features:

# Year values:

```{r}
unique_year = unique(as.factor(Rent$year))
print(unique_year)

years_count = table(Rent$year)
print(years_count)
```

# Neighborhood values:

```{r}
unique_nhood = unique(as.factor(Rent$nhood))
print(unique_nhood)

nhood_count = table(Rent$nhood)
print(nhood_count)

# 167 nhoods
```

# City values:

```{r}
unique_city = unique(as.factor(Rent$city))
print(unique_city)

city_count = table(Rent$city)
print(city_count)

# 104 cities
```

# County values:

```{r}
unique_county = unique(as.factor(Rent$county))
print(unique_county)

county_count = table(Rent$county)
print(county_count)

# 10 counties
```

# Removing unnecessary columns:

```{r}
Rent = Rent %>% select(-room_in_apt, -lat, -lon, -address, -descr, -details)
head(Rent)
```

# Checking count of rows with at least 1 NA value:

```{r}
count_na_rows = sum(apply(Rent, 1, function(x) any(is.na(x))))
print(count_na_rows)
```

# Checking count of NA value in each column:

```{r}
na_count_year = sum(is.na(Rent$year))
print(paste("NA count year:", na_count_year))

na_count_nhood = sum(is.na(Rent$nhood))
print(paste("NA count nhood:", na_count_nhood))

na_count_city = sum(is.na(Rent$city))
print(paste("NA count city:", na_count_city))

na_count_county = sum(is.na(Rent$county))
print(paste("NA count county:", na_count_county))

na_count_price = sum(is.na(Rent$price))
print(paste("NA count price:", na_count_price))

na_count_beds = sum(is.na(Rent$beds))
print(paste("NA count beds:", na_count_beds))

na_count_baths = sum(is.na(Rent$baths))
print(paste("NA count baths:", na_count_baths))

na_count_sqft = sum(is.na(Rent$sqft))
print(paste("NA count sqft:", na_count_sqft))

na_count_title = sum(is.na(Rent$title))
print(paste("NA count title:", na_count_title))

```

# Removing rows with NAs for title, county, beds, baths, and sqft

```{r}
Rent_cleaned <- Rent %>%
  filter(!is.na(title), !is.na(county), !is.na(beds), !is.na(baths), !is.na(sqft))

Rent_cleaned
```

# Checking for complete rows (no NAs):

```{r}
complete_rows = sum(complete.cases(Rent))

print(complete_rows)
```

# Checking for Outliers:

```{r}

detective = function(column) {

  Q1 = quantile(column, 0.25, na.rm = TRUE)
  Q3 = quantile(column, 0.75, na.rm = TRUE)
  IQR = Q3 - Q1
  
  lower_bound = Q1 - 1.5 * IQR
  upper_bound = Q3 + 1.5 * IQR
  
  outliers = column < lower_bound | column > upper_bound
  
  return(outliers)
}

price_outliers = detective(Rent_cleaned$price)
num_outliers_price = sum(price_outliers)
print(paste("Price outlier count:", num_outliers_price))

bed_outliers = detective(Rent_cleaned$beds)
num_outliers_bed = sum(bed_outliers)
print(paste("Bed outlier count:", num_outliers_bed))

sqft_outliers = detective(Rent_cleaned$sqft)
num_outliers_sqft = sum(sqft_outliers)
print(paste("sqft outlier count:", num_outliers_sqft))

bath_outliers = detective(Rent_cleaned$baths)
num_outliers_bath = sum(bath_outliers)
print(paste("Bath outlier count:", num_outliers_bath))
```

# Visualizing outliers:

```{r}
boxplot(Rent_cleaned$price, 
        main = "Box Plot of Rent Prices", 
        ylab = "Price", 
        col = "lightblue",
        outline = TRUE)  

boxplot(Rent_cleaned$baths, 
        main = "Box Plot of baths", 
        ylab = "baths", 
        col = "lightblue",
        outline = TRUE)  

boxplot(Rent_cleaned$sqft, 
        main = "Box Plot of sqft", 
        ylab = "sqft", 
        col = "lightblue",
        outline = TRUE)  

boxplot(Rent_cleaned$beds, 
        main = "Box Plot of beds", 
        ylab = "beds", 
        col = "lightblue",
        outline = TRUE)  


```

# Remove Outliers:

```{r}
Rent_cleaned <- Rent_cleaned %>%
  filter(
    !detective(price),
    !detective(beds),
    !detective(baths),
    !detective(sqft)
  )
```

# Correlation Analysis:

```{r}
numeric_complete_rent <- Rent_cleaned %>% select(where(is.numeric))

cor_matrix = cor(numeric_complete_rent, use = "pairwise.complete.obs")

ggcorrplot(cor_matrix, lab = TRUE)
```

# Histogram of Price:

```{r}
ggplot(Rent_cleaned, aes(x = price)) +
  geom_histogram(binwidth = 250, color = "black", fill = "skyblue") +
  labs(title = "Histogram of Price", x = "Price", y = "Count") +
  theme_minimal() +
  coord_cartesian(xlim = c(0, 20000))
```

# Histogram of sqft:

```{r}
ggplot(Rent_cleaned, aes(x = sqft)) +
  geom_histogram(binwidth = 100, color = "black", fill = "skyblue") +
  labs(title = "Histogram of Price", x = "sqft", y = "Count") +
  theme_minimal() + 
  coord_cartesian(xlim = c(0, 10000))
```

# Bar Plot of beds:

```{r}
ggplot(Rent_cleaned, aes(x = beds)) +
  geom_bar(color = "black", fill = "skyblue") +
  labs(title = "Bar Plot of beds", x = "Number of beds", y = "Count") +
  theme_minimal()
```

# Bar Plot of baths:

```{r}
ggplot(Rent_cleaned, aes(x = baths)) +
  geom_bar(color = "black", fill = "skyblue") +
  labs(title = "Bar Plot of baths", x = "Number of baths", y = "Count") +
  theme_minimal()
```

# Bar Plot for year:

```{r}
ggplot(Rent_cleaned, aes(x = factor(year))) +  
  geom_bar(color = "black", fill = "skyblue") +  
  labs(title = "Bar Plot of Year", x = "Year", y = "Count") +  
  theme_minimal()
```

-   For nhood beware has some countys in it...

# Feature Engineering:

```{r}
Rent_num = Rent_cleaned

price_per_sqft = Rent_cleaned$price / Rent_cleaned$sqft 
price_per_bed = Rent_cleaned$price / Rent_cleaned$beds
price_per_bath = Rent_cleaned$price / Rent_cleaned$baths

Rent_num$price_per_sqft = price_per_sqft
Rent_num$price_per_bed = price_per_bed
Rent_num$price_per_bath = price_per_bath

Rent_num = Rent_num %>% select(-title)

Rent_num
```

# Visualizations of the New Features

```{r}
ggplot(Rent_num, aes(x = price_per_sqft)) +
  geom_histogram(binwidth = 5, color = "black", fill = "lightgreen") +
  labs(title = "Histogram of Price per Sqft", x = "Price per Sqft", y = "Count") +
  theme_minimal()

ggplot(Rent_num, aes(x = price_per_bed)) +
  geom_histogram(binwidth = 100, color = "black", fill = "lightcoral") +
  labs(title = "Histogram of Price per Bed", x = "Price per Bed", y = "Count") +
  theme_minimal()

ggplot(Rent_num, aes(x = price_per_bath)) +
  geom_histogram(binwidth = 200, color = "black", fill = "lightblue") +
  labs(title = "Histogram of Price per Bed", x = "Price per Bed", y = "Count") +
  theme_minimal()
```

# EDA Visualizations for Relationships Among Variables:

```{r}
ggplot(Rent_num, aes(x = sqft, y = price)) + 
  geom_point(aes(color = price), alpha = 0.6) + 
  scale_color_gradient(low = "blue", high = "red") + 
  labs(
    title = "Price vs. Square Footage",
    x = "Square Footage",
    y = "Price"
  ) + 
  theme_minimal() + 
  theme(legend.position = "none")


ggplot(Rent_num, aes(x = nhood, y = price)) +
  geom_boxplot(fill = "lightblue", color = "blue", outlier.colour = "red") +
  labs(title = "Price Distribution by Neighborhood", 
       x = "Neighborhood", 
       y = "Price") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


ggplot(Rent_num, aes(x = sqft, y = price_per_sqft)) +
  geom_point(color = "blue", alpha = 0.6) +
  labs(title = "Price per Square Foot vs. Square Footage",
       x = "Square Footage",
       y = "Price per Square Foot") +
  theme_minimal()


ggplot(Rent_num, aes(x = baths, y = price_per_bath)) +
  geom_point(color = "green", alpha = 0.6) +
  labs(title = "Price per Bath vs. Number of Baths",
       x = "Number of Baths",
       y = "Price per Bath") +
  theme_minimal()
```

# Scale Numeric Features

Standardize/normalize numeric features in dataset.

```{r}
numeric_cols <- Rent_num |> select(where(is.numeric)) |> names()
Rent_num[numeric_cols] <- scale(Rent_num[numeric_cols])
```

# Correlation Analysis with the new features:

```{r}
numeric_complete_rent2 <- Rent_num %>% select(where(is.numeric))

cor_matrix2 <- cor(numeric_complete_rent2, use = "pairwise.complete.obs")

ggcorrplot(cor_matrix2, lab = TRUE)
```

# Data Set/Extra Cleanup for PCA:

***For predict neighborhood / county / city by price:\
Rent_price (190,618 x 8) --\> id, date, year, nhood, city, county,
price, title***

***For predicting price by square footage: Rent_cleaned_sqft (61,056 x
9) --\> id, date, year, nhood, city, county, sqft, price, title***

***For finding relationships between year and price: Rent_price (190,618
x 8) --\> id, date, year, nhood, city, county, price, title***

***For predicting \# of beds by price: Rent_price (190,618 x 8) --\> id,
date, year, nhood, city, county, price, title***

```{r}
Rent_analysis <- Rent_num |>
  select(price, sqft, beds, baths, price_per_sqft, price_per_bed, price_per_bath)

# Step 2: Clean the data by handling NA and infinite values
# Replace NA values with the column mean, and handle Inf values
Rent_analysis <- Rent_analysis |>
  mutate(across(everything(), ~ ifelse(is.na(.), mean(., na.rm = TRUE), .))) |>
  mutate(across(everything(), ~ ifelse(is.infinite(.), NA, .))) %>%
  drop_na() 
```

# PCA ANALYSIS:

***NEED TO CHANGE WRITING BELOW:***

***Engineer new features: - price_per_sqft = price / sqft --\>
"Rent_cleaned_sqft" - price_per_bed = price / bed --\> "Rent_price" -
price_per_bathroom = price / bath --\> "Rent_cleaned_baths"***

***7 features to work with***

***DF: Rent_for_PCA***

***CHANGE WRIITNG ABOVE:***

## Perform PCA

First standardize the data, then perform PCA, and view the PCA loadings.
The PCA loadings (the relationship between original variables and
principal components). This will help understand how each feature
contributes to each principal component

```{r PCA}
Rent_PCA <- Rent_analysis |>
  select(where(~ !all(is.na(.))))

Rent_PCA <- Rent_PCA |>
  select(where(~ var(.) != 0))

Rent_PCA_scaled <- scale(Rent_PCA)

pca_result <- prcomp(Rent_PCA_scaled, center = TRUE, scale. = TRUE)

# Scree Plot using factoextra
fviz_screeplot(pca_result, addlabels = TRUE, title = "Scree Plot")

summary(pca_result)

print(pca_result$rotation)
```

## Proportion of Variance for each PC

This tells you how much of the variability in the data is explained by
each component

```{r}
proportion_variance <- summary(pca_result)$importance[2, ]
print(proportion_variance)
```

## Visualize the first two PCs. 

```{r}
ggplot(pca_data, aes(x = PC1, y = PC2)) +
  geom_point(color = "blue", alpha = 0.6) +  
  theme_minimal() +
  labs(title = "PCA: First vs. Second Principal Component", 
       x = "Principal Component 1", y = "Principal Component 2")


barplot(pca_result$rotation[,1], las = 2, col = "darkblue", main = "Loadings for PC1")

barplot(pca_result$rotation[,2], las = 2, col = "darkblue", main = "Loadings for PC2")
```

## Visualize the Variance of PCs.

```{r}
variance_explained <- summary(pca_result)$importance[2, ]
ggplot(data.frame(PC = 1:length(variance_explained), Variance_Explained = variance_explained), 
       aes(x = factor(PC), y = Variance_Explained)) +
  geom_bar(stat = "identity", fill = "skyblue") +
  labs(title = "Variance Explained by Each Principal Component", x = "Principal Component", y = "Variance Explained")
```

## Normalized

```{r}
sum(pca_result$rotation[,1]^2)
```

## Contribution of Variables to PCs

```{r}
fviz_contrib(pca_result, choice = "var", axes = 1, title = "Contribution of Variables to PC1")
fviz_contrib(pca_result, choice = "var", axes = 2, title = "Contribution of Variables to PC2")

```

## PCA Bipolot

```{r}
fviz_pca_biplot(pca_result, repel = TRUE, title = "PCA Biplot")
```

## Create dataframe with results

The principal components (scores) are stored in pca_result\$x, which we
convert into a dataframe.

```{r}
pca_data <- data.frame(pca_result$x) 
```

## Individual Component Contributions

```{r}
top_PC1 <- rownames(pca_data)[order(pca_data$PC1, decreasing = TRUE)[1:10]]
top_PC2 <- rownames(pca_data)[order(pca_data$PC2, decreasing = TRUE)[1:10]]
print(top_PC1)
print(top_PC2)
```

# Factor Analysis:

Select relevant columns for factor analysis, only numeric ones:
`price_per_sqft`, `price_per_bed`, and `price_per_bath`, `price`,
`sqft`, `beds`, and `bath.` We will use the Rent_for_PCA dataframe.

```{r}
# Determine the optimal number of factors using parallel analysis
fa.parallel(Rent_analysis, fa = "fa", n.iter = 100, show.legend = TRUE,
            main = "Parallel Analysis Scree Plot")

# Based on the output, choose the number of factors (assuming 3 here)
factor_analysis <- fa(Rent_factor_data, nfactors = 3, rotate = "varimax")

# View the factor loadings to interpret results
print(factor_analysis$loadings)   
print(factor_analysis)           

#Visualize the factor loadings
fa.diagram(factor_analysis, main = "Factor Analysis Diagram")


```

Other version:

```{r}

# Step 4: Perform factor analysis with the selected number of factors (assuming 3 factors)
factor_analysis <- fa(Rent_factor_data, nfactors = 3, rotate = "varimax")

# Step 5: View the factor loadings to interpret results
print(factor_analysis)

```

....

# CLUSTERING

Property Segmentation: Cluster sqft, price, beds, and baths to group
similar types of properties --\> clusters might represent luxury homes,
small apartments, or family homes\
- complete_Rent

Market Segmentation by Location: Cluster based on city, county, or nhood
combined with property attributes like price and sqft to find
location-based patterns - complete_rent

K-Means Clustering:

```{r}

# Step 1: Standardize the data (important for clustering algorithms)
Rent_factor_data_scaled <- scale(Rent_factor_data)

# Step 2: Perform K-means Clustering
set.seed(123)  # For reproducibility
kmeans_result <- kmeans(Rent_factor_data_scaled, centers = 3, nstart = 25)  # Assume 3 clusters

# Step 3: View clustering results
print(kmeans_result)  # Output of the K-means clustering

# Step 4: Add cluster assignment to the data
Rent_factor_data$cluster <- kmeans_result$cluster

# Step 5: Visualize the clusters (optional, if you have only 2 or 3 dimensions)
library(ggplot2)
Rent_factor_data %>%
  ggplot(aes(x = price, y = sqft, color = factor(cluster))) +
  geom_point() +
  theme_minimal() +
  labs(title = "K-means Clustering (Price vs. Sqft)", color = "Cluster")

```

Hierarchical Clustering:

```{r}
# Step 1: Data Preparation (already done in previous steps)

# Step 2: Standardize the data
Rent_factor_data_scaled <- scale(Rent_factor_data)

# Step 3: Compute the distance matrix
distance_matrix <- dist(Rent_factor_data_scaled)

# Step 4: Perform hierarchical clustering
hclust_result <- hclust(distance_matrix, method = "ward.D2")  # "ward.D2" is often a good method

# Step 5: Plot the dendrogram
plot(hclust_result, main = "Hierarchical Clustering Dendrogram", xlab = "", ylab = "Height")

# Step 6: Cut the tree to get clusters (e.g., 3 clusters)
hclust_clusters <- cutree(hclust_result, k = 3)

# Step 7: Add cluster assignments to the data
Rent_factor_data$cluster <- hclust_clusters

# Step 8: Visualize the clusters (optional, if you have only 2 or 3 dimensions)
Rent_factor_data %>%
  ggplot(aes(x = price, y = sqft, color = factor(cluster))) +
  geom_point() +
  theme_minimal() +
  labs(title = "Hierarchical Clustering (Price vs. Sqft)", color = "Cluster")

```

# K-means Clustering (trying to find meaningful clusters)

-   high rent areas (cities)

```{r}
library(cluster)

Rent_price <- Rent_price %>%
  mutate(city = as.numeric(as.factor(city)))  


data_scaled <- Rent_price %>%
  mutate(price = scale(price)) %>%
  select(price, city)  


set.seed(123)
k <- 8 

kmeans_result <- kmeans(data_scaled, centers = k)


Rent_price$cluster <- as.factor(kmeans_result$cluster)


ggplot(Rent_price, aes(x = city, y = price, color = cluster)) +
  geom_point(size = 1) +
  labs(title = "Rent Clusters by Price and City",
       x = "City",
       y = "Price") +
  theme_minimal()

# clustered by scaled price and encoded cities
```

# Clustering sqft by price:

```{r}
set.seed(123)  
k = 10  

kmeans_result = kmeans(complete_Rent[, c("price", "sqft")], centers = k)

complete_Rent$cluster = as.factor(kmeans_result$cluster)

ggplot(complete_Rent, aes(x = sqft, y = price, color = cluster)) +
  geom_point(size = 1) +
  labs(title = "Rent Clusters by Price and Square Feet",
       x = "Square Feet",
       y = "Price") +
  theme_minimal()


```

# Clustering Price by sqft:

```{r}
set.seed(123)  
k = 10  

kmeans_result = kmeans(complete_Rent[, c("price", "sqft")], centers = k)

complete_Rent$cluster = as.factor(kmeans_result$cluster)

ggplot(complete_Rent, aes(x = price, y = sqft, color = cluster)) +
  geom_point(size = 1) +
  labs(title = "Rent Clusters by Price and Square Feet",
       x = "Square Feet",
       y = "Price") +
  theme_minimal()
```

# Citations

1.  Session 1 and 2 Lab: Data Preprocessing and Visualization Notebook
